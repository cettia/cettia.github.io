---
layout: default
title: A full-featured real-time web application framework for Java
---
<div class="grid-container">
  <div class="grid-x">
    <div class="cell">
      <div class="content">
        <h1>Cettia</h1>
        <h4 class="subheader">A real-time web application framework for Java</h4>
        <p>Cettia is a full-featured real-time web application framework that you can use to exchange events between server and client in real-time. Following the separation of concerns principle, the framework is separated into 3 layers; 1. I/O framework agnostic layer to run a Cettia application on any I/O framework on Java Virtual Machine 2. Transport layer to provide a reliable full duplex message channel 3. Socket layer to offer elegant patterns to achieve better user experience in the real-time web. This multi-layered architecture allows for focusing on application-level real-time event handling only, as well as a greater freedom of choice on technical stacks.</p>
        <p>Getting started:</p>
        <ul>
          <li><a href="/guides/cettia-tutorial/">Building Real-Time Web Applications With Cettia</a></li>
        </ul>
        {% assign post = site.posts.first %}
        <hr />
        <p><a href="https://github.com/{{ post.author }}"><img
          src="https://github.com/{{ post.author }}.png" alt="{{ post.author }}" width="24"
          height="24"> {{ post.author }}</a> wrote <a href="{{ post.url }}">{{ post.title }}</a> on {{
          post.date | date: "%B %-d, %Y" }}.</p>
        <hr />
        <p>Here are key features.</p>
  {% capture panel %}
  - I/O framework agnostic
      - Reactive everywhere. When adopting an I/O framework to serve your application, you should be able to select it according to performance, productivity, familiarity and so on with no regard to this kind of framework.
      - That's why Cettia is designed to run on any I/O framework on Java Virtual Machine (JVM) seamlessly without degrading the underlying framework's performance. Now Atmosphere, Grizzly, Java Servlet, Java WebSocket API, Netty and Vert.x are supported.
      - Even if your favorite I/O framework is not supported, donâ€™t worry. With more or less 200 code lines, you can write a bridge to your framework and run Cettia via that bridge.
  - Reliable full duplex connection
      - If given proxy, firewall, anti-virus software or arbitrary Platform as a Service (PaaS), it's very difficult to be absolutely-sure that WebSocket will just work. You still need "Comet" in 2018, a set of giant hacks for HTTP server-push defined more than 10 years ago.
      - HTTP-based transports Cettia provides i.e. streaming and long polling can carry, not only text but also binary payload based on message framing bidirectionally in real-time just like WebSocket. They just work in the wild.
      - Of course, you don't need to (and should not) know under the hood details. Just open a socket and register event handlers. Cettia will do the rest and call your event handlers.
  - Elegant suite of patterns
      - WebSocket's message event is not flexible enough to branch your logic especially in handling text and binary data together. Cettia provides the event system which allows to define your own events regardless of the type of data. No more boilerplate code.
      - One of common pitfalls in working on real world user stories is regarding a user as a single socket. Instead, you should send event to all browsers and devices the user signed in. To help this, Cettia provides a concise API that allows to regard a set of sockets as a single entity.
      - Whatever the reason is, it's inevitable that the connection is disconnected. To help you handle disconnection declaratively, Cettia provides separate events for temporary disconnection and permanent disconnection along with events failed to send during disconnection.
  - Scalable horizontally
      - Because the location of the socket is transparent and Cettia servers don't share any data, you can scale your application horizontally with publish-subscribe model like Java Message Service (JMS). Of course, you don't need to modify existing event handlers.
      - Within the microservice architecture or the serverless architecture, it's possible to scale out only the Cettia part of your application using publish-subscribe solution, which is much more cost-effective comparing to the monolithic architecture.
      - With the cloud computing service supporting autoscaling like Amazon Web Service, Microsoft Azure and Google Cloud Platform, it's quite easy to set up scalable cluster of Cettia.
  {% endcapture %}{{ panel | markdownify }}
      </div>
    </div>
  </div>
</div>
